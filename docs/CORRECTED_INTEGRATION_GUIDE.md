# Sunday Schemas - Corrected Integration Guide

> **Updated guide with accurate type definitions and working examples**

## üö® **IMPORTANT CORRECTION**

This guide replaces the previous integration documentation which contained **inaccurate type definitions**. The examples below are based on the **actual working implementation** used in sunday-connectors.

## üìã Verified Type Definitions

### Go Module Structure

The Go module contains **two sets of types**:

1. **`types.go`** - **‚úÖ RECOMMENDED** - Used by sunday-connectors
2. **`schemas.go`** - Generated by different tool, different field naming

**Always use the types from `types.go`** for consistency with existing Sunday platform services.

---

## Go Usage (Corrected)

### Basic Import
```go
import schemas "github.com/rakeyshgidwani/sunday-schemas/codegen/go"
```

### Working with Raw Events ‚úÖ

**Correct `RawEnvelope` structure:**
```go
type RawEnvelope struct {
    Schema           string      `json:"schema"`
    VenueID          string      `json:"venue_id"`
    Stream           string      `json:"stream"`
    InstrumentNative string      `json:"instrument_native"`
    PartitionKey     string      `json:"partition_key"`
    TsEventMs        int64       `json:"ts_event_ms"`        // ‚ö†Ô∏è Note: TsEventMs (not TsEventMS)
    TsIngestMs       int64       `json:"ts_ingest_ms"`       // ‚ö†Ô∏è Note: TsIngestMs (not TsIngestMS)
    IsHistorical     *bool       `json:"is_historical,omitempty"`
    BackfillTsMs     *int64      `json:"backfill_ts_ms,omitempty"`
    Payload          interface{} `json:"payload"`
}
```

### Creating Events ‚úÖ **VERIFIED WORKING**
```go
// This is the exact pattern used in sunday-connectors
func CreateRawEvent(venueID, stream, instrument string, payload interface{}) schemas.RawEnvelope {
    now := time.Now().UTC()
    return schemas.RawEnvelope{
        Schema:           string(schemas.SchemaRAW_V0),     // ‚úÖ Correct constant
        VenueID:          venueID,
        Stream:           stream,
        InstrumentNative: instrument,
        PartitionKey:     venueID + ":" + instrument,
        TsEventMs:        now.UnixMilli(),                  // ‚úÖ Correct field name
        TsIngestMs:       now.UnixMilli(),                  // ‚úÖ Correct field name
        Payload:          payload,
    }
}
```

### Validation ‚úÖ **VERIFIED WORKING**
```go
// Validate venue
if err := schemas.ValidateVenue("polymarket"); err != nil {
    return fmt.Errorf("invalid venue: %w", err)
}

// Validate schema
if err := schemas.ValidateSchema("raw.v0"); err != nil {
    return fmt.Errorf("invalid schema: %w", err)
}

// Validate complete event
func ValidateEvent(event schemas.RawEnvelope) error {
    if err := schemas.ValidateVenue(event.VenueID); err != nil {
        return err
    }
    return schemas.ValidateSchema(event.Schema)
}
```

### Working with Venue Constants ‚úÖ
```go
// Use auto-generated constants from schemas.go
switch schemas.VenueID(event.VenueID) {
case schemas.Polymarket:
    processPolymarketEvent(event)
case schemas.Kalshi:
    processKalshiEvent(event)
default:
    return fmt.Errorf("unsupported venue: %s", event.VenueID)
}
```

### Market Data Events ‚úÖ

**OrderbookDelta structure:**
```go
type OrderbookDelta struct {
    Schema       string      `json:"schema"`
    InstrumentID string      `json:"instrument_id"`
    VenueID      string      `json:"venue_id"`
    TsMs         int64       `json:"ts_ms"`               // ‚ö†Ô∏è Note: TsMs (not TsMS)
    Seq          int64       `json:"seq"`                 // ‚úÖ Sequence field exists
    Bids         [][]float64 `json:"bids"`               // ‚úÖ [price, size] pairs
    Asks         [][]float64 `json:"asks"`               // ‚úÖ [price, size] pairs
    IsSnapshot   bool        `json:"is_snapshot"`
}
```

**Trade structure:**
```go
type Trade struct {
    Schema       string   `json:"schema"`
    InstrumentID string   `json:"instrument_id"`
    VenueID      string   `json:"venue_id"`
    TsMs         int64    `json:"ts_ms"`
    Side         string   `json:"side"`                   // "buy" | "sell"
    Prob         float64  `json:"prob"`                   // Implied probability [0.0, 1.0]
    Size         float64  `json:"size"`
    NotionalUsd  *float64 `json:"notional_usd,omitempty"`
}
```

---

## Complete Working Example

### Event Processing Pipeline ‚úÖ
```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "time"

    schemas "github.com/rakeyshgidwani/sunday-schemas/codegen/go"
)

type EventProcessor struct {
    handlers map[string]func(schemas.RawEnvelope) error
}

func NewEventProcessor() *EventProcessor {
    ep := &EventProcessor{
        handlers: make(map[string]func(schemas.RawEnvelope) error),
    }

    ep.handlers["orderbook"] = ep.handleOrderbook
    ep.handlers["trades"] = ep.handleTrades

    return ep
}

func (ep *EventProcessor) ProcessRawEvent(data []byte) error {
    var event schemas.RawEnvelope
    if err := json.Unmarshal(data, &event); err != nil {
        return fmt.Errorf("failed to unmarshal: %w", err)
    }

    // Validate using schema functions
    if err := schemas.ValidateVenue(event.VenueID); err != nil {
        return fmt.Errorf("invalid venue: %w", err)
    }

    if err := schemas.ValidateSchema(event.Schema); err != nil {
        return fmt.Errorf("invalid schema: %w", err)
    }

    // Route to handler
    handler, exists := ep.handlers[event.Stream]
    if !exists {
        log.Printf("No handler for stream: %s", event.Stream)
        return nil
    }

    return handler(event)
}

func (ep *EventProcessor) handleOrderbook(event schemas.RawEnvelope) error {
    log.Printf("Processing orderbook: %s:%s at %d",
        event.VenueID, event.InstrumentNative, event.TsEventMs)

    // Process orderbook payload
    if orderbookData, ok := event.Payload.(map[string]interface{}); ok {
        // Handle venue-specific orderbook format
        switch schemas.VenueID(event.VenueID) {
        case schemas.Polymarket:
            return ep.processPolymarketOrderbook(orderbookData)
        case schemas.Kalshi:
            return ep.processKalshiOrderbook(orderbookData)
        }
    }

    return nil
}

func (ep *EventProcessor) handleTrades(event schemas.RawEnvelope) error {
    log.Printf("Processing trade: %s:%s at %d",
        event.VenueID, event.InstrumentNative, event.TsEventMs)

    // Similar processing for trades...
    return nil
}

func (ep *EventProcessor) processPolymarketOrderbook(data map[string]interface{}) error {
    // Polymarket-specific processing
    log.Println("Processing Polymarket orderbook")
    return nil
}

func (ep *EventProcessor) processKalshiOrderbook(data map[string]interface{}) error {
    // Kalshi-specific processing
    log.Println("Processing Kalshi orderbook")
    return nil
}

// Example usage
func main() {
    processor := NewEventProcessor()

    // Example raw event JSON (this structure is correct)
    exampleEvent := `{
        "schema": "raw.v0",
        "venue_id": "polymarket",
        "stream": "orderbook",
        "instrument_native": "test-instrument",
        "partition_key": "polymarket:test-instrument",
        "ts_event_ms": 1234567890000,
        "ts_ingest_ms": 1234567890000,
        "payload": {
            "bids": [[0.45, 100], [0.44, 200]],
            "asks": [[0.55, 150], [0.56, 250]]
        }
    }`

    if err := processor.ProcessRawEvent([]byte(exampleEvent)); err != nil {
        log.Fatal(err)
    }

    fmt.Println("Event processed successfully!")
}
```

---

## Field Name Reference

### ‚ùå **INCORRECT** (from previous documentation)
```go
// Don't use these field names - they don't exist
TsEventMS        // Wrong capitalization
TsIngestMS       // Wrong capitalization
BidsDelta        // Wrong field name
AsksDelta        // Wrong field name
Sequence         // Use Seq instead
```

### ‚úÖ **CORRECT** (actual field names)
```go
// Use these exact field names
TsEventMs        // Correct: camelCase with lowercase 's'
TsIngestMs       // Correct: camelCase with lowercase 's'
Bids             // Correct: Direct field name
Asks             // Correct: Direct field name
Seq              // Correct: Abbreviated sequence
```

---

## Validation Reference ‚úÖ

### Available Constants
```go
// Schema constants
schemas.SchemaRAW_V0                    // "raw.v0"
schemas.SchemaMD_ORDERBOOK_DELTA_V1     // "md.orderbook.delta.v1"
schemas.SchemaMD_TRADE_V1               // "md.trade.v1"

// Venue constants
schemas.Polymarket                      // "polymarket"
schemas.Kalshi                          // "kalshi"

// All schemas and venues
allSchemas := schemas.AllSchemas()      // []EventSchema
allVenues := schemas.AllVenues()        // []VenueID
```

### Validation Functions
```go
// These functions are verified working
err := schemas.ValidateSchema("raw.v0")
err := schemas.ValidateVenue("polymarket")

// Get all supported values
schemas := schemas.AllSchemas()
venues := schemas.AllVenues()
```

---

## Integration Checklist ‚úÖ

For sunday-data team:

- [ ] ‚úÖ Install with GOPRIVATE: `go env -w GOPRIVATE=github.com/rakeyshgidwani/sunday-schemas`
- [ ] ‚úÖ Import: `import schemas "github.com/rakeyshgidwani/sunday-schemas/codegen/go"`
- [ ] ‚úÖ Use `schemas.RawEnvelope` type (not `RawEnvelopeV0`)
- [ ] ‚úÖ Use field names: `TsEventMs`, `TsIngestMs` (lowercase 's')
- [ ] ‚úÖ Use constants: `schemas.Polymarket`, `schemas.Kalshi`
- [ ] ‚úÖ Use schema constants: `schemas.SchemaRAW_V0`
- [ ] ‚úÖ Use validation: `schemas.ValidateVenue()`, `schemas.ValidateSchema()`
- [ ] ‚úÖ Test with the complete working example above

---

## Differences from Previous Guide

| Previous (Incorrect) | Corrected | Notes |
|---------------------|-----------|-------|
| `RawEnvelopeV0` | `RawEnvelope` | Use types.go version |
| `TsEventMS` | `TsEventMs` | Lowercase 's' |
| `TsIngestMS` | `TsIngestMs` | Lowercase 's' |
| `BidsDelta` | `Bids` | Direct field name |
| `AsksDelta` | `Asks` | Direct field name |
| `Sequence` | `Seq` | Abbreviated |

---

**This guide is based on the actual working implementation in sunday-connectors and has been verified against the current Go module structure.**